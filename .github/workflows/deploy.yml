name: Build Docker Image, Deploy on Server

on:
  push:
    branches:
      - main

jobs:
  # --- ЗАДАЧА №1: ПРОВЕРКА, СБОРКА DOCKER-ОБРАЗА И ЗАПУСК ТЕСТОВ/ЛОГОВ В ОБЛАКЕ ---
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_name: ${{ steps.string.outputs.DOCKER_IMAGE_NAME_LC }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Apply code formatting with Spotless
        run: ./gradlew spotlessApply

      # --- НОВЫЙ ШАГ: ЗАПУСК SPRING BOOT ТЕСТОВ ---
      - name: Run Spring Boot Tests
        run: ./gradlew test # Запускает все JUnit тесты, включая Spring Boot тесты
        # Если у вас есть профили Spring, и тесты требуют определенный профиль, используйте:
        # run: ./gradlew test -Dspring.profiles.active=test

      # --- НОВЫЙ ШАГ: ЗАПУСК ПРИЛОЖЕНИЯ В ТЕСТОВОМ РЕЖИМЕ И СБОР ЛОГОВ В СБОРКЕ ---
      - name: Run application for a short period and capture logs
        # Цель этого шага: убедиться, что приложение стартует, и увидеть начальные логи.
        # Это не полноценный запуск, а скорее "проверка на жизнеспособность".
        # Перенаправляем STDOUT/STDERR в файл, чтобы потом его вывести, если понадобится,
        # хотя в GitHub Actions весь вывод консоли и так сохраняется.
        run: |
          # Собираем JAR-файл, если 'test' его не создал (зависит от вашей gradle-конфигурации)
          ./gradlew assemble

          echo "Attempting to run application for a short period to capture startup logs..."
          # Запускаем JAR-файл вашего Spring Boot приложения.
          # -Dserver.port=0: Рандомный порт, чтобы избежать конфликтов.
          # > startup.log 2>&1: Перенаправляем весь вывод (STDOUT и STDERR) в файл startup.log.
          # &: Запускаем процесс в фоновом режиме.
          # spring.profiles.active=ci: Опционально, если хотите запускать в CI-профиле.
          java -Dserver.port=0 -jar build/libs/*.jar > startup.log 2>&1 &
          APP_PID=$! # Запоминаем PID фонового процесса

          echo "Waiting for application to start (max 30 seconds)..."
          # Ждем некоторое время, чтобы приложение успело запуститься и сгенерировать логи
          # Это можно улучшить, проверяя, слушает ли порт, или ища конкретную строку в логах
          sleep 30

          echo "Killing application process..."
          kill $APP_PID || true # Убиваем процесс, если он ещё жив. '|| true' предотвращает ошибку, если процесс уже завершился.

          echo "Printing captured startup logs:"
          cat startup.log # Выводим содержимое файла логов в консоль сборки GitHub Actions
          echo "End of application startup logs."
        # Если вы хотите, чтобы сборка провалилась, если приложение не стартует успешно,
        # то шагу 'java -jar...' не нужно запускаться в фоне, и 'sleep' нужно заменить
        # на более надёжный механизм ожидания старта.

      - name: Convert repository name to lowercase
        id: string
        run: echo "DOCKER_IMAGE_NAME_LC=$(echo ghcr.io/${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.string.outputs.DOCKER_IMAGE_NAME_LC }}:latest

  # --- ЗАДАЧА №2: ДЕПЛОЙ НА RASPBERRY PI ---
  deploy:
    needs: build
    runs-on: self-hosted

    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Debug secrets
        run: |
          echo "Available secrets:"
          echo "BOT_TOKEN: ${{ secrets.BOT_TOKEN != null }}"
          echo "BOT_NAME: ${{ secrets.BOT_NAME != null }}"
          echo "EXTERNAL_VOLUME_PATH: ${{ secrets.EXTERNAL_VOLUME_PATH != null }}"

      - name: Deploy new version to Docker
        run: |
          IMAGE_NAME="${{ needs.build.outputs.image_name }}:latest"
          CONTAINER_NAME="obed-bot"

          echo "Pulling latest Docker image: $IMAGE_NAME"
          docker pull $IMAGE_NAME

          echo "Stopping and removing old container if it exists..."
          docker stop $CONTAINER_NAME || true
          docker rm $CONTAINER_NAME || true

          echo "Starting new container with environment variables and volume..."
          # Запускаем новый контейнер, передавая секреты как переменные окружения и прокидывая волюм
          docker run \
            -d \
            --restart always \
            -e BOT_TOKEN=${{ secrets.BOT_TOKEN }} \
            -e BOT_NAME=${{ secrets.BOT_NAME }} \
            -e BOT_MAIN_USER_CHAT_ID=${{ secrets.BOT_MAIN_USER_CHAT_ID }} \
            -e BOT_TIME_ZONE="Asia/Yekaterinburg" \
            -v ${{ secrets.EXTERNAL_VOLUME_PATH }}:/app/data \
            --name $CONTAINER_NAME \
            $IMAGE_NAME
          
          echo "Cleaning up old images..."
          docker image prune -f

          echo "Deployment finished!"